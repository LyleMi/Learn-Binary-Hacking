基础
========================================

简介
----------------------------------------

发展历史
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 1959年 虚拟化概念提出 Christopher Strachey在国际信息处理大会上发表了虚拟化相关的文章
- 1960年 早期计算机虚拟化 IBM研究出了IBM 7044计算机 让用户可以在一台大型机上运行多个系统
- 1965年，IBM开发了 System/360 Model 40 VM。
- 1998年，VMware诞生。
- 1999年 现代计算机虚拟化实现 VMware解决了x86虚拟化的问题，推出了虚拟化软件
- 2003年 开源虚拟化技术出现 Xen是剑桥的一个开源项目，是版虚拟化技术的代表
- 2005年 硬件辅助虚拟化技术出现 Intel和ADM推出了支持虚拟化技术的处理器和芯片组，实现了硬件辅助虚拟化技术
- 2006年 虚拟化技术在云计算中应用

定义
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
虚拟化是表示计算机资源的抽象方法，通虚拟化可以用于访问抽象前资源一致的方法访问抽象的资源。这种资源的抽象方法并不受实现、地理位置底层资源的物理配置的限制。

概念
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
虚拟化 (Virtualization）指的是对资源进行抽象的过程；虚拟机 (Virtual Machine) 是对真实机器的抽象，例如JVM，程序无需关心底层的硬件逻辑。

仿真器 (Emulator) 关心外在表现，即是否能代替原本的产品使用，并不复刻内部逻辑；模拟器 (Simulator) 核心在于模拟原本产品的内部状态。

虚拟化中比较重要的两个概念是Host和Guest，其中Host多指物理资源，而Guest是指虚拟出来的资源。与之对应的，存在宿主机(Host Machine)、宿主机操作系统(Host OS)，客户机(Guest Machine)、客户机操作系统(Guest OS)。

层次
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
虚拟化可以分为硬件虚拟化、操作系统虚拟化、库函数虚拟化、编程语言虚拟化。硬件虚拟化直接虚拟化硬件资源，操作系统虚拟化多指操作系统提供的用户隔离机制。库函数则是通过类似WINE一类的方式向应用层屏蔽了操作系统内部的细节。编程语言的虚拟化是类似JVM等的实现，将程序代码翻译为硬件的机器语言再进行执行。

意义
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 效率：将原本一台服务器的资源分配给了多台虚拟化的服务器，有效地利用了闲置资源。
- 隔离：虚拟环境中运行的应用程序之间的隔离性优于在传统的非虚拟化系统中运行的应用程序，这对于系统的安全性和可用性都有所提升。
- 可靠：虚拟服务器是独立与硬件进行工作的，通过改进灾难恢复解决方案提高了业务的连续性。当一台服务器出现故障时可在最短时间内恢复且不影响整个集群的运作，在整个数据中心实现高可用性。
- 成本：降低了部署成本，只需要更少的服务器就可实现需要更多服务器才能做到的事情，也间接降低了安全等其他方面的成本。
- 兼容：虚拟化技术改进了桌面管理的方式，可部署多套不同的系统，将因兼容性造成问题的可能性降到最低。
- 便于管理：提高了服务器/管理员比率，一个管理员可以轻松地管理比以前更多的服务器而不会造成更大的负担。

原理
----------------------------------------
- 非特权指令
    - 可以在任何级别下执行
- 特权指令
    - 操作和管理系统资源，只能在最高权限级 ring0 上运行
    - 其他权限运行触发异常被捕获
- 敏感指令
    - 操作特权资源的指令，读写敏感的寄存器或内存，访问内存系统或IO指令。
    - 部分为特权指令，17条非特权指令
    - 所有的特权指令都是敏感指令。但不是所有的敏感指令都是特权指令
    - x86架构下部分敏感指令可在低权限级别运行，不触发异常，不能被捕获

CPU虚拟化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 指令翻译
    - 二进制代码动态翻译
    - 在执行时动态地重写虚拟机的执行代码
    - 在需要 VMM 监控和模拟的位置插入陷入
    - 不需要修改 guest OS
    - 动态翻译带来一定的性能开销
- 指令翻译模拟器
    - 虚拟化技术的实质是一样的：将底层资源进行分区，并向上提供特定的和多样化的执行环境
    - 纯软件方法模拟和实际运行程序不同的指令集去执行，这种方式构造的虚拟机一般称为模拟器
    - 模拟器可将 guest OS发出的所有指令翻译成本地指令集
    - 指令集虚拟化系统的代表包括 Bochs 和 QEMU 等
- Bochs
    - x86 PC模拟器 可以运行在大多主流平台上，包括x86 PowerPC Alpha Sun和MIPS
    - 翻译每一条指令
    - 从加电到重新启动模拟x86 CPU，为所有标准PC外围设备装配设备模型，支持无修改软件执行(包括操作系统)
    - 模拟需要额外开销
- QEMU
    - 使用动态翻译器，Kqemu使用指令翻译缓冲区快速处理指令翻译
    - 支持两种操作模式：User Mode和System Mode
    - 在User Mode中，可以将CPU上编译的Linux进程装载到另一个CPU中，或跨编译进行交叉调试
    - 在System Mode中，可以模拟完整系统，包括处理器和外围设备
    - QEMU支持多种处理器架构的模拟，包括x86、ARM、PowerPC和Sparc

计算机虚拟化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- VMM(Virtual Machine Monitor) 虚拟机监控层：运行于服务器硬件和虚拟机之间的中间软件层，又称为hypervisor
    - 管理所有的系统资源
    - 管理虚拟机，提供虚拟机硬件模拟
    - 协调虚拟机使用服务器硬件
- 宿主机操作系统：host OS
- 客户机操作系统：guest OS
- 计算机虚拟化
    - CPU/内存/IO虚拟化

虚拟化方式分类
----------------------------------------
- 半虚拟化 (Para-Virtualization)
    - 客户操作系统通过修改能和物理硬件进行互动，效率较高，代表是Xen
    - 实现方式：修改操作系统
    - 和全虚拟化相比，架构更精简，而且在整体速度上有一定的优势。
    - 缺点是需要对Guest OS进行修改，所以在用户体验上不太好，对非开放的操作系统则无法提供支持
- 完全虚拟化 (Full Virtualization)
    - 客户操作系统不用修改，硬件由VMM模拟，指令也由VMM进行模拟并返回给客户操作系统
    - 实现方式
        - 软件实现：要经过模拟处理，性能较低，对系统负荷较大
        - 硬件辅助：通过修改虚拟机和VMM运行的ring级别，提高性能

半虚拟化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
半虚拟化 (Para-Virtualization) 在部分翻译中也被称作部分虚拟化、类虚拟化、协同虚拟化。具体来说，这种技术并不是实在的硬件抽象，而是一种修改过的形式。

- CPU半虚拟化
    - 在半虚拟化实现中，认为与其千方百计去捕获敏感指令，不如直接不用这些指令。于是对GuestOS进行了一些修改，替换掉这些指令，转而调用VMM提供的特殊API(hypercall)来进行模拟。当Guest OS需要执行敏感操作时，直接通过hypercall调用VMM，避免了捕获的开销。
    - 不需要hypervisor捕获特权指令而耗费一定的资源进行翻译操作，从而获得额外的性能和高扩展性，使其性能非常接近物理机
    - 这种方式需要修改操作系统内核，将不能虚拟化的指令替换为hypercall，hypercall直接与虚拟层通信，虚拟层提供内核操作的关键接口，如内存管理、中断处理和时间管理等。
- 内存半虚拟化
    - 在VMM的帮助下，使guest OS能够利用物理MMU一次完成由虚拟机地址到机器地址的三层转换技术
    - guest OS的客户页表中的地址不再是客户物理地址，而是机器地址
    - 为了保护各个虚拟机内存空间相互独立，VMM在对页表进行地址替换前，会对页表中的每一个页表项进行检查，以确保只映射了属于该虚拟机的机器页面，而且不得包含对页表页面的可写映射
- I/O设备半虚拟化
    - 在半虚拟化下，修改Guest OS内核，将原生设备驱动从Guest OS中移出，放在一个经过VMM授权的设备虚拟机中，其余虚拟机中Guest OS的I/O请求都交由设备虚拟机处理。

全虚拟化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 在虚拟化技术的早期，计算机没有在硬件层次上对虚拟化技术提供支持，因此虚拟化技术主要基于软件实现。
- 完全虚拟化方法在虚拟服务器和底层硬件之间建立一个抽象层，捕捉和处理那些对虚拟化敏感的特权指令，为指令访问硬件控制器和外设充当中介，使客户操作系统无需修改就能在虚拟服务器上运行，就像运行在真实的物理环境下一样。
- 主要实现技术
    - 优先级压缩
    - 二进制代码翻译
- CPU全虚拟化
    - 客户操作系统运行在Ring 1级，VMM运行在Ring 0级，VMM提供给操作系统各种虚拟资源(虚拟BIOS、虚拟设备和虚拟内存管理等)。对于不能虚拟化的特权指令，通过二进制转换方式转换为同等效果的指令序列运行，而用户级指令可直接运行
- 内存全虚拟化
    - 影子页表
        - 虚拟地址 <=> 物理地址
        - 虚拟机虚拟地址 <=> 虚拟机物理地址 <=> 真实的机器地址
    - 影子页表对guest OS完全透明
    - 维护影子页表的时间开销和空间开销很大
        - 缺页补全
        - 每个虚拟机到需要一套影子页表
- I/O设备全虚拟化
    - 不修改guest OS
    - VMM处理设备的方式根据VMM的位置不同
- 全虚拟化
    - 代表产品
        - VMware vSphere和Hyper-V
        - 开源KVM
    - 优点
        - Guest OS无需修改
    - 缺点
        - 开销
- 全虚拟化-硬件辅助
    - 指令虚拟化
        - 用户指令直接在硬件上执行
        - 部分特权指令直接执行
        - 部分特权指令在VMM上执行
    - 存储器的虚拟化
        - NPT
        - 影子页表
    - I/O设备
        - 指令模拟
        - Intel - VT
- 硬件辅助虚拟化
    - 代表产品
        - Virtual Box / KVM
    - 优点
        - 引入硬件技术，使虚拟化技术更接近物理机的速度
    - 缺点
        - 硬件实现不够优化，还有提高空间

虚拟化抽象目标分类
----------------------------------------
- 指令集虚拟化 (ISA Level Virtualization)
- 硬件抽象层虚拟化 (Hardware Abstraction Level Virtualization)
- 操作系统层虚拟化 (OS Level Virtualization)
- 运行库虚拟化 (Library Level Virtualization)
- 语言层虚拟化 (Programming Language Level Virtualization)

虚拟化技术应用
----------------------------------------

内核漏洞检测
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- User Space
    - 部署一些分析和测试的应用程序
- Kernel Space
    - 主要工作包括设置监视的内存区域、与超级管理程序通信、拦截特定的函数
- Hypervisor
    - 主要负责进行具体的监测检查工作

完整性保护
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
完整性是指能够保障被传输、接收或存储的信息是完整的和未被篡改的，是信息安全的重要属性之一。关于完整性保护的研究主要集中在文件系统完整性和内核代码完整性方面。

入侵检测
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
现有的入侵检测系统给系统管理员带来了两难的选择：如果将入侵检测系统部署在主机上，则它可以清晰的观察到主机的系统状态，但是容易遭到恶意攻击或者被屏蔽；如果将其部署在网络上，则它可以更好的抵御攻击，但是对主机内部的状态一无所知，因此可能让攻击者逃脱。

基于虚拟化的入侵检测系统，可以做到既能够观察到被监控系统的内部状态，又能与被监控系统隔离。VMM能够直接观察到被监控系统的内部状态，可以通过直接访问其内存来重构出GuestOS的内核数据结构，通过单独运行的入侵检测系统来进行检测。这种在虚拟机外部监控虚拟机内部运行状态的方法称为虚拟机自省(virtual machine introspection, VMI)。

恶意代码检测与分析
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 原理
    - 恶意软件具有静态的特征码，其感染破坏的流程中存在行为特征
    - 恶意软件入侵系统后会进行隐藏系统进程、添加注册表启动项等操作
- 现有解决方案
    - 基于多引擎的特征码和行为特征检测
    - 基于入侵检测
